#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>

//1.数据类型介绍

//整型家族：
//char - unsigned char / signed char --- char是不是signed char取决于编译器
//short - unsigned short / signed short
//int - unsigned int / signed int
//long - unsigned long / signed long

//浮点型家族：
//float
//double

//构造类型：自定义类型
//数组类型
//结构体类型 struct
//枚举类型 enum
//联合类型 union

//指针类型
//int* pi
//char* pc
//float* pf
//void* pv

//空类型
//void表示空类型（无类型）
//通常应用于函数的返回类型、函数的参数、指针类型


//2.整型在内存中的存储：原码、反码、补码
//正数的原、反、补码都相同
//负数
//内存中存储的都是二进制数据
//
//int main()
//{
//	int a = 20;
//	//00000000 00000000 00000000 00010100 - 原、反、补码
//
//	int b = -10;
//	//10000000 00000000 00000000 00001010 - 原码
//	//11111111 11111111 11111111 11110101 - 反码
//	//11111111 11111111 11111111 11110110 - 补码
//	return 0;
//}

//对于整型，数据存放在内存中的是补码
//在计算机系统中，数值一律用补码来表示和存储，原因在于，使用补码，可以将符号位和数值域统一处理；
//同时，加法和减法也可以统一处理(CPU只有加法器)，此外，补码和原码相互转换，其运算过程是相同的，不需要额外的硬件电路
//取反加一


//3.大小端字节序 --- 以字节为单位
//大端：低位字节，存储在高地址处；高位字节，存储在低地址处
//小端：低位字节，存储在低地址处；高位字节，存储在高地址处

//取决于硬件

//百度面试题：解释大小字节序的概念，设计一个小程序来判断当前机器的字节序
//查看内存里第一个字节的数据 --- 指针解引用的步长不同
//int main()
//{
//	int a = 1;
//	char* pc = (char*)&a;
//	if (*pc == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//	return 0;
//}

//int sys_chk()
//{
//	int a = 1;
//	return *(char*)&a;
//}

//例1：
//int main()
//{
//	char a = -1;
//	//截断、整型提升
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	//%d --- 有符号数,十进制
//	//%u --- 无符号数,十进制
//	return 0;
//}

//1 byte = 8 bit
//有符号char的取值范围  11111111 ~ 00000000 ~ 01111111 -> -128(10000000) ~ 0(00000000) ~ 127
//无符号char的取值范围  0 ~ 255

//short
//有符号 -2^15 ~ 2^15 - 1
//无符号 0 ~ 2^16 - 1

//int
//有符号 -2^31 ~ 2^31 - 1
//无符号 0 ~ 2^32 - 1

//打印的格式要匹配

//例2：
//int main()
//{
//	char a = -128;
//	//char a = 128; //128 = 127 + 1 = -128
//	printf("%u\n", a);
//	//整型提升的时候看的是a的类型，打印的时候看的是%u
//	return 0;
//}

//例3：
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	//类型转换 -> 补码 -> 计算 -> 原码
//	printf("%d\n", i + j);
//	return 0;
//}

//例4：
//#include <Windows.h>
//int main()
//{
//	unsigned int i; //无符号数 >= 0
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(1000);
//		//到 -1 存补码
//	}
//	return 0;
//}

//例5：
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));
//	// char 类型的取值范围 -128 ~ 127
//	// 超出范围模运算循环
//	// strlen()求字符串长度，找的是\0，ASCLL码是0，不包括\0
//	return 0;
//}

//例6：
//unsigned int i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world!\n");
//	}
//	return 0;
//}



//4.浮点型在内存中的存储解析
//整型家族的类型的取值范围  limits.h
//浮点型家族的类型的取值范围： float.h

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("num的值为：%d\n", n);
	printf("*pFloat的值为：%f\n", *pFloat);
	return 0;
}

//浮点数存储标准
//IEEE 754 --- 任意一个二进制浮点数V可以表示成下面的形式
//(-1)^S * M * 2^E
//(-1)^S 表示符号位，当S=0，V为正数；S=1，V为负数
//M 表示有效数字，大于等于1，小于2
//2^E 表示指数位

//对于32位的单精度浮点数float， 最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M
//对于64位的双精度浮点数double，最高的1位是符号位S，接着的11位是指数E，剩下的52位有效数字M

//对有效数字M和指数E，特别规定：
//在计算机内部保存 M 时，默认这个数的第一位总是1，因此可以被舍弃，只保留后面的部分

//不是所有的浮点数都能精确保存

//指数E是一个无符号整数
//存入内存时，E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127，对于11位的E，中间数是1023

//int main()
//{
//	float f = 5.5f;
//
//	return 0;
//}

//指数E从内存中取出来分为三种情况
//E不全为0或不全为1：指数E的计算值减去127(或1023)，得到真实值，再将有效数字M前加上第一位的1
//E全为0：浮点数的指数E等于1-127(或者1-1023)即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxx的小数，这样做是为了表示±0，以及接近于0的很小的数字
//E全为1：如果有效数字M全为0，表示±无穷大(正负取决于符号位S)








