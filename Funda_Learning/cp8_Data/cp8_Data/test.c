#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

// 1. 数据类型

// 1.1 整型家族 - char short int long 

// signed - 有符号的，也就是有正负
// unsigned - 无符号的

// short int long 默认是 signed
// char 默认值取决于编译器，大多数是signed


// 1.2 浮点型 - float double

// 1.3 构造类型
// 数组
// 枚举类型 enum
// 结构体 struct
// 联合体 union

// 1.4 空类型(无类型) - void
// 用于函数的返回类型、函数的参数、指针类型

// void func(void) - 函数没有返回值，函数不需要参数
// void* p - 指针指向的类型不固定


// 2. 整型在内存中的存储
// 2.1 原码、反码、补码
// 第一位是符号位 + 数值位

// 正数 - 原码、反码、补码相同
// 负数
// 原码 - 数值的二进制表示
// 反码 - 符号位不变，其它位依次按位取反
// 补码 - 反码+1

// 补码得到原码 - 按位取反，然后+1

// 对于整型来说，内存中存放的就是 补码

// 计算机系统中，数值一律用补码来表示和存储，原因在于：补码可以将符号位和数值域统一处理
// 同时，加法和减法也可以统一处理(CPU只有加法器)
// 此外，补码和原码相互转换，运算过程是相同的，不需要额外的硬件电路


// 2.2 大小端位序存储
// 大端存储 - 数据的 低位 保存在内存的 高地址 中
// 小段存储 - 数据的 低位 保存在内存的 低地址 中

// 原因：计算机系统中，以字节为单位，每个地址单元都对应着一个字节，一个字节为8bit
// 但是在C语言中除了8bit的char类型之外，还有16bit的short类型、32bit的int类型
// 对于大于8位的处理器，寄存器宽度大于一个字节，必然存在如何安排多个字节的问题，导致了大端和小端存储模式


// 设计小程序判断当前机器的字节序

//int check_sys(void)
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	if (check_sys() == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


// 整数放到 char 类型中会首先发生截断
// 使用的时候会进行 整型提升

//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	printf("a=%d b=%d c=%d\n", a, b, c);
//	return 0;
//}

// char 类型的范围：-2^7 ~ 2^-1
// 10000000 - -128
// 11111111 - -1
// 00000000 - 0


// 整型提升是看数据原本的类型
// 打印的时候看占位符的类型

//int main()
//{
//	//char a = -128;
//	// 100000000000000000000010000000 - 原
//	// 111111111111111111111101111111 - 反
//	// 111111111111111111111110000000 - 补
//	// 10000000 - 截断
//	
//	char a = 128;
//	
//	printf("%u\n", a);
//	// 输出的时候先对 -128 进行整型提升，按照 char 类型
//	// 111111111111111111111110000000
//	// 然后按照 %u 的方式输出
//	return 0;
//}


//int  main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
// 整型运算按照补码的形式进行运算
// int 和 unsigned int 都能存储两个数字，不需要发生截断，直接用原数字进行计算 -10
// %d 按照有符号整型输出，所以结果是 -10



//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}
// unsigned int 的范围 >=0，所以死循环，0，-1，-2...按照 %u 无符号整型的方式输出，所以是unsigned int的最大值



//#include <string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d\n", strlen(a));
//	return 0;
//}
// a数组的元素类型是char
// char 类型的范围是-128~127，-1、-2、...、-128、127、126、...、1、0、-1... 循环
// strlen 输出的是 \0 之前的元素个数，\0的ASCII码值是0，所以结果是128+127


//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}
// unsigned char 取值范围是0~255，死循环



// 3. 浮点型的存储

//int main()
//{
//	int n = 9;
//	float* pFloat = (float*) & n;
//
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//	
//	*pFloat = 9.0;
//	printf("n的值为：%d\n", n);
//	printf("*pFloat的值为：%f\n", *pFloat);
//
//	return 0;
//}

// 3.1 浮点数存储规则
// IEEE754 国际电气和电子工程协会

// 一个浮点数可以表示成：
// (-1)^S * 2^E * M
// S - 符号位，S=0表示正数，S=-1表示负数
// E - 指数位
// M - 有效数字，>=1,<=2

// 5.5 可以表示成：
// 101.1 - (-1)^0 * 2^2 * 1.011
// S=0, E=2, M=1.011

// float - 32位单精度浮点数
// 1位符号位S + 8位指数位E + 23位有效数字M

// double - 64位双精度浮点数
// 1位符号位S + 11位指数位E + 52位有效数字M

// 有效数字 M 的规定：
// M可以写成 1.xxxx 的形式，其中xxxx表示小数部分
// 计算机存储 M 时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxx部分
// 节省1位有效数字

// 指数 E 的规定：
// E 是一个无符号整数 unsigned int，8位的取值范围0~255，11位的取值范围0~2047
// 科学计数法中的E是可以出现 负数 的，所以存入的时候，E的真实值必须再加上一个中间数
// 8位E加上127，11位E加上1023
// 

// 内存中取出浮点数
// E 不全为0 或 不全为1
// 浮点数：指数E的 计算值 减去127(或者1023)，得到 真实值，再将有效数字M加上第一位的1

// E 全为0
// 浮点数的指数 E 等于 1-127(或者1-1023)，即为真实值
// 有效数字M不再加上第一位的1，而是还原为0.xxxxx的小数
// 表示 ±0，或者接近于0的很小的数字

// E 全为1
// 如果有效数字M全为0，表示 ±无穷大，取决于符号位S



